
#include "ing_hash_table_new.h"

#include "ing_core_utils.h"

#include <stdlib.h>
#include <string.h>
#include <math.h>


/// table of prime numbers, but they're spaced out kind of geometrically (not sure if that's the mathematically correct terminology)
/// basically, this table was generated by taking a number (initially set to 1) and multiplying it by 1.5, and then setting it to the next prime number after that value.
/// this process is then repeated for all the entries in the table, up until about 2^48
static const size_t geometric_size_table__[] = {
        0,
        1,
        3,
        5,
        11,
        17,
        29,
        47,
        71,
        107,
        163,
        251,
        379,
        569,
        857,
        1289,
        1949,
        2927,
        4391,
        6599,
        9901,
        14867,
        22303,
        33457,
        50207,
        75323,
        112997,
        169501,
        254257,
        381389,
        572087,
        858149,
        1287233,
        1930879,
        2896319,
        4344479,
        6516739,
        9775111,
        14662727,
        21994111,
        32991187,
        49486793,
        74230231,
        111345347,
        167018017,
        250527029,
        375790553,
        563685851,
        845528713,
        1268293123,
        1902439697,
        2853659651,
        4280489489,
        6420733997,
        9631100951,
        14446651399,
        21669978119,
        32504967211,
        48757448743,
        73136177209,
        109704265739,
        164556406801,
        246834610189,
        370251923527,
        555377885191,
        833066827783,
        1249600209001,
        1874400378901,
        2811600568327,
        4217400983573,
        6326101475347,
        9489152475139,
        14233729237051,
        21350592806941,
        32025889210457,
        48038831718419,
        72058243383311,
        108087365074979,
        162131056001039,
        243196584001589,
        364794859225091
};

static void linked_list_prepend_(ing_linked_list_node** ll, void* value, size_t value_size_in_bytes) {
    ing_linked_list_node* new_front_node = malloc(sizeof(ing_linked_list_node) + value_size_in_bytes);
    memcpy(&new_front_node->value, value, value_size_in_bytes);
    new_front_node->next = *ll;

    (*ll) = new_front_node;
}

static void linked_list_init_(ing_linked_list_node** node, void* value, size_t value_size_in_bytes) {
    *node = malloc(sizeof(ing_linked_list_node) + value_size_in_bytes);
    (*node)->next = NULL;
    memcpy((*node)->value, value, value_size_in_bytes);
}

static void linked_list_append_(ing_linked_list_node** end_node, void* value, size_t value_size_in_bytes) {
    ing_internal_assert((*end_node)->next == NULL);

    ing_linked_list_node* new_node;
    linked_list_init_(&new_node, value, value_size_in_bytes);
    (*end_node)->next = new_node;
}

void ing_linked_list_destroy(ing_linked_list_node* ll, void(*element_destructor)(void*)) {
    if(ll) {
        ing_linked_list_destroy(ll->next, element_destructor);
        element_destructor(ll);
        free(ll);
    }
}

bool ing_default_is_equal(void* a, void* b, size_t sizeof_element_type) {
    return (memcmp(a, b, sizeof_element_type) == 0);                                                                               \
}

void ING_INTERNAL_hash_table_init(ing_hash_table* ht, size_t sizeof_element_type,
                                  size_t (*hash_function)(void* element),
                                  bool   (*is_equal)(void* element_a, void* element_b),
                                  void   (*element_destructor)(void* element),
                                  size_t default_hash_and_comparison_initial_sequence_length) {

    memset(ht, 0, sizeof(*ht));
                                                                                    // I destroy the elements of the linked lists manually in ing_linked_list_destroy
    ING_INTERNAL_dynamic_array_init(&ht->array_of_linked_list, sizeof(ing_linked_list_node*), NULL);

    ht->hash_function                                       = hash_function;
    ht->is_equal                                            = is_equal;
    ht->sizeof_element_type                                 = sizeof_element_type;
    ht->default_hash_and_comparison_initial_sequence_length = default_hash_and_comparison_initial_sequence_length;
    ht->element_destructor                                  = element_destructor;
}

/*
ing_hash_table ING_INTERNAL_hash_table_create(size_t sizeof_element_type,
                                              void(*hash_function)(void* element),
                                              void(*is_equal)(void* element_a, void* element_b),
                                              void(*element_destructor)(void* element)) {

    ing_hash_table ret;
    ING_INTERNAL_hash_table_init(&ret, sizeof_element_type,
                    hash_function,
                    is_equal,
                    element_destructor);

    return ret;
}

ing_hash_table* ING_INTERNAL_hash_table_create_on_heap(size_t sizeof_element_type,
                                                       void(*hash_function)(void* element),
                                                       void(*is_equal)(void* element_a, void* element_b),
                                                       void(*element_destructor)(void* element)) {

    ing_hash_table* ret = malloc(sizeof(ing_hash_table));
    ING_INTERNAL_hash_table_init(ret, sizeof_element_type, hash_function, is_equal, element_destructor);

    return ret;
}
*/

size_t ing_default_hash_cstring(const char* value) {
    /// source for this implementation: http://www.cse.yorku.ca/~oz/hash.html
    size_t hash = 5381;

    char c;
    while(c = *value++) {
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    }

    return hash;
    /// /source
}

// same as ing_default_hash_cstring, but takes a void* and size insted of a null terminated string
size_t ing_default_hash(void* value, size_t size_in_bytes) {
    if(size_in_bytes <= sizeof(size_t)) { // the object fits in a size_t, so just memcpy it in
        size_t hash = 0;
        memcpy(&hash, value, size_in_bytes);
        return hash;
    }
    else {
        /// source for this implementation: http://www.cse.yorku.ca/~oz/hash.html
        size_t hash = 5381;

        for(size_t i = 0; i < size_in_bytes; ++i) {
            hash = ((hash << 5) + hash) + ((char*)value)[i]; /* hash * 33 + c */
        }

        return hash;
        /// /source
    }
}

static size_t get_hash_index_(const ing_hash_table* ht, void* value) {
    size_t ret;
    if(ht->hash_function) {
        ret = ht->hash_function(value);
    }
    else {
        ret = ing_default_hash(value, ht->default_hash_and_comparison_initial_sequence_length);
    }

    return ret % ing_hash_table_buckets_count(ht);
}

static bool do_equals_comparison_(const ing_hash_table* ht, void* a, void* b) {
    if(ht->is_equal) {
        return ht->is_equal(a, b);
    }
    else {
        return (memcmp(a, b, ht->default_hash_and_comparison_initial_sequence_length) == 0);
    }
}

typedef struct {
    ing_linked_list_node* node;
    bool table_already_contained_value;
} get_node_to_insert_after_return_type_;


bool ing_hash_table_contains(const ing_hash_table* ht, void* value) {

    if(!ing_hash_table_buckets_count(ht)) {
        return false;
    }

    size_t index = get_hash_index_(ht, value);

    ing_linked_list_node* node = ing_dynamic_array_at_as_void_ptr(&ht->array_of_linked_list, index);

    while(node) {
        if(do_equals_comparison_(ht, node->value, value)) {
            return true;
        }

        node = node->next;
    }

    return false;
}

size_t is_prime_(size_t n) {
    size_t sqrt_n = sqrt(n);
}

// TODO: some kind of ING_STATIC_IF_NOT_DEBUG thing here
static size_t next_prime_after_(size_t n) {
    if(n%2 == 0) {
        n += 1; // add 1 if n is even, because only odd number can be prime
    }


    for(;;) {
        if(is_prime_(n)) {
            return n;
        }

        n += 2;
    }
}

static void rehash_(ing_hash_table* ht, size_t new_bucket_count) {
    ing_dynamic_array old_array = ht->array_of_linked_list;

    {
        ing_dynamic_array new_array;
        ing_dynamic_array_init(ing_linked_list_node*, &new_array, NULL);
        ing_dynamic_array_resize(&new_array, new_bucket_count);

        ht->array_of_linked_list = new_array;
    }

    for(size_t i = 0; i < old_array.size; ++i) {
        ing_linked_list_node* node = ing_dynamic_array_at_as_void_ptr(&old_array, i);
        while(node) {
            size_t index = get_hash_index_(ht, node->value);
            // ing_dynamic_array_at(ing_linked_list_node*, &ht->array_of_linked_list, index) =

            ing_linked_list_node* node_copy = node;
            //ing_linked_list_node**
            //void* linked_list_head = (node_copy->next = ing_dynamic_array_at_as_void_ptr(&ht->array_of_linked_list, index));

            // this might look kind of weird, but all I'm doing is prepending
            ing_linked_list_node** head = ing_dynamic_array_at_ptr(&ht->array_of_linked_list, index); // use ing_dynamic_array_at_ptr because we want a pointer TO the element (which is, itself, a pointer) at index, not the element itself
            *head = node_copy;
            // ht->array_of_linked_list

            node = node->next;
        }
    }

    ing_dynamic_array_destroy(&old_array);
}

static void conditional_rehash_(ing_hash_table* ht, size_t additional_entries_count) {
    const float max_load_factor = .75f;

    float current_load_factor = (float)(ht->entries_count+additional_entries_count) / ing_hash_table_buckets_count(ht);
    if(current_load_factor > max_load_factor) {
        while(geometric_size_table__[++ht->index_in_size_table] < (ing_hash_table_buckets_count(ht) + additional_entries_count)) {}
        rehash_(ht, geometric_size_table__[ht->index_in_size_table]);
    }
}

bool ing_hash_table_insert(ing_hash_table* ht, void* value) {
    conditional_rehash_(ht, 1);

    size_t index = get_hash_index_(ht, value);

    ing_linked_list_node** node = ing_dynamic_array_at_ptr(&ht->array_of_linked_list, index);

    while(*node && (*node)->next) {
        if(do_equals_comparison_(ht, (*node)->value, value)) {
            return false;
        }

        if((*node)->next) {
            (*node) = (*node)->next;
        }
        else {
            break;
        }
    }

    // at this point, we can be sure that value doesn't already exist in ht,
    if((*node)) {
        linked_list_append_(node, value, ht->sizeof_element_type);
    }
    else {
        linked_list_init_(node, value, ht->sizeof_element_type);
    }

    return true;
}

size_t ing_hash_table_buckets_count(const ing_hash_table* ht) {
    return ht->array_of_linked_list.size;
}